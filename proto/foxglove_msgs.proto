// Generated by https://github.com/foxglove/foxglove-sdk

syntax = "proto3";

import "google/protobuf/timestamp.proto";

package foxglove;

// A [quaternion](https://eater.net/quaternions) representing a rotation in 3D space
message Quaternion {
  // x value
  double x = 1;

  // y value
  double y = 2;

  // z value
  double z = 3;

  // w value
  double w = 4;
}

// A vector in 3D space that represents a direction only
message Vector3 {
  // x coordinate length
  double x = 1;

  // y coordinate length
  double y = 2;

  // z coordinate length
  double z = 3;
}

// A position and orientation for an object or reference frame in 3D space
message Pose {
  // Point denoting position in 3D space
  foxglove.Vector3 position = 1;

  // Quaternion denoting orientation in 3D space
  foxglove.Quaternion orientation = 2;
}

// A single scan from a planar laser range-finder
message LaserScan {
  // Timestamp of scan
  google.protobuf.Timestamp timestamp = 1;

  // Frame of reference
  string frame_id = 2;

  // Origin of scan relative to frame of reference; points are positioned in the x-y plane relative to this origin; angles are interpreted as counterclockwise rotations around the z axis with 0 rad being in the +x direction
  foxglove.Pose pose = 3;

  // Bearing of first point, in radians
  double start_angle = 4;

  // Bearing of last point, in radians
  double end_angle = 5;

  // Distance of detections from origin; assumed to be at equally-spaced angles between `start_angle` and `end_angle`
  repeated double ranges = 6;

  // Intensity of detections
  repeated double intensities = 7;
}


// Camera calibration parameters
message CameraCalibration {
  // Timestamp of calibration data
  google.protobuf.Timestamp timestamp = 1;

  // Frame of reference for the camera. The origin of the frame is the optical center of the camera. +x points to the right in the image, +y points down, and +z points into the plane of the image.
  string frame_id = 9;

  // Image width
  fixed32 width = 2;

  // Image height
  fixed32 height = 3;

  // Name of distortion model
  // 
  // Supported parameters: `plumb_bob` (k1, k2, p1, p2, k3) and `rational_polynomial` (k1, k2, p1, p2, k3, k4, k5, k6). Distortion models are based on [OpenCV's](https://docs.opencv.org/2.4/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html) [pinhole camera model](https://en.wikipedia.org/wiki/Distortion_%28optics%29#Software_correction). This is the same [implementation used by ROS](http://docs.ros.org/en/diamondback/api/image_geometry/html/c++/pinhole__camera__model_8cpp_source.html)
  string distortion_model = 4;

  // Distortion parameters
  repeated double D = 5;

  // Intrinsic camera matrix (3x3 row-major matrix)
  // 
  // A 3x3 row-major matrix for the raw (distorted) image.
  // 
  // Projects 3D points in the camera coordinate frame to 2D pixel coordinates using the focal lengths (fx, fy) and principal point (cx, cy).
  // 
  // ```
  //     [fx  0 cx]
  // K = [ 0 fy cy]
  //     [ 0  0  1]
  // ```
  repeated double K = 6; // length 9

  // Rectification matrix (stereo cameras only, 3x3 row-major matrix)
  // 
  // A rotation matrix aligning the camera coordinate system to the ideal stereo image plane so that epipolar lines in both stereo images are parallel.
  repeated double R = 7; // length 9

  // Projection/camera matrix (3x4 row-major matrix)
  // 
  // ```
  //     [fx'  0  cx' Tx]
  // P = [ 0  fy' cy' Ty]
  //     [ 0   0   1   0]
  // ```
  // 
  // By convention, this matrix specifies the intrinsic (camera) matrix of the processed (rectified) image. That is, the left 3x3 portion is the normal camera intrinsic matrix for the rectified image.
  // 
  // It projects 3D points in the camera coordinate frame to 2D pixel coordinates using the focal lengths (fx', fy') and principal point (cx', cy') - these may differ from the values in K.
  // 
  // For monocular cameras, Tx = Ty = 0. Normally, monocular cameras will also have R = the identity and P[1:3,1:3] = K.
  // 
  // For a stereo pair, the fourth column [Tx Ty 0]' is related to the position of the optical center of the second camera in the first camera's frame. We assume Tz = 0 so both cameras are in the same stereo image plane. The first camera always has Tx = Ty = 0. For the right (second) camera of a horizontal stereo pair, Ty = 0 and Tx = -fx' * B, where B is the baseline between the cameras.
  // 
  // Given a 3D point [X Y Z]', the projection (x, y) of the point onto the rectified image is given by:
  // 
  // ```
  // [u v w]' = P * [X Y Z 1]'
  //        x = u / w
  //        y = v / w
  // ```
  // 
  // This holds for both images of a stereo pair.
  repeated double P = 8; // length 12
}

// A compressed image
message CompressedImage {
  // Timestamp of image
  google.protobuf.Timestamp timestamp = 1;

  // Frame of reference for the image. The origin of the frame is the optical center of the camera. +x points to the right in the image, +y points down, and +z points into the plane of the image.
  string frame_id = 4;

  // Compressed image data
  bytes data = 2;

  // Image format
  // 
  // Supported values: `jpeg`, `png`, `webp`, `avif`
  string format = 3;
}

// A raw image
message RawImage {
  // Timestamp of image
  google.protobuf.Timestamp timestamp = 1;

  // Frame of reference for the image. The origin of the frame is the optical center of the camera. +x points to the right in the image, +y points down, and +z points into the plane of the image.
  string frame_id = 7;

  // Image width
  fixed32 width = 2;

  // Image height
  fixed32 height = 3;

  // Encoding of the raw image data
  // 
  // Supported values: `8UC1`, `8UC3`, `16UC1` (little endian), `32FC1` (little endian), `bayer_bggr8`, `bayer_gbrg8`, `bayer_grbg8`, `bayer_rggb8`, `bgr8`, `bgra8`, `mono8`, `mono16`, `rgb8`, `rgba8`, `uyvy` or `yuv422`, `yuyv` or `yuv422_yuy2`
  string encoding = 4;

  // Byte length of a single row
  fixed32 step = 5;

  // Raw image data
  bytes data = 6;
}

// A single frame of a compressed video bitstream
message CompressedVideo {
  // Timestamp of video frame
  google.protobuf.Timestamp timestamp = 1;

  // Frame of reference for the video.
  // 
  // The origin of the frame is the optical center of the camera. +x points to the right in the video, +y points down, and +z points into the plane of the video.
  string frame_id = 2;

  // Compressed video frame data.
  // 
  // For packet-based video codecs this data must begin and end on packet boundaries (no partial packets), and must contain enough video packets to decode exactly one image (either a keyframe or delta frame). Note: Foxglove does not support video streams that include B frames because they require lookahead.
  // 
  // Specifically, the requirements for different `format` values are:
  // 
  // - `h264`
  //   - Use Annex B formatted data
  //   - Each CompressedVideo message should contain enough NAL units to decode exactly one video frame
  //   - Each message containing a key frame (IDR) must also include a SPS NAL unit
  // 
  // - `h265` (HEVC)
  //   - Use Annex B formatted data
  //   - Each CompressedVideo message should contain enough NAL units to decode exactly one video frame
  //   - Each message containing a key frame (IRAP) must also include relevant VPS/SPS/PPS NAL units
  // 
  // - `vp9`
  //   - Each CompressedVideo message should contain exactly one video frame
  // 
  // - `av1`
  //   - Use the "Low overhead bitstream format" (section 5.2)
  //   - Each CompressedVideo message should contain enough OBUs to decode exactly one video frame
  //   - Each message containing a key frame must also include a Sequence Header OBU
  bytes data = 3;

  // Video format.
  // 
  // Supported values: `h264`, `h265`, `vp9`, `av1`.
  // 
  // Note: compressed video support is subject to hardware limitations and patent licensing, so not all encodings may be supported on all platforms. See more about [H.265 support](https://caniuse.com/hevc), [VP9 support](https://caniuse.com/webm), and [AV1 support](https://caniuse.com/av1).
  string format = 4;
}


// A navigation satellite fix for any Global Navigation Satellite System
message LocationFix {
  // Type of position covariance
  enum PositionCovarianceType {
    UNKNOWN = 0;

    APPROXIMATED = 1;

    DIAGONAL_KNOWN = 2;

    KNOWN = 3;
  }
  // Timestamp of the message
  google.protobuf.Timestamp timestamp = 6;

  // Frame for the sensor. Latitude and longitude readings are at the origin of the frame.
  string frame_id = 7;

  // Latitude in degrees
  double latitude = 1;

  // Longitude in degrees
  double longitude = 2;

  // Altitude in meters
  double altitude = 3;

  // Position covariance (m^2) defined relative to a tangential plane through the reported position. The components are East, North, and Up (ENU), in row-major order.
  repeated double position_covariance = 4; // length 9

  // If `position_covariance` is available, `position_covariance_type` must be set to indicate the type of covariance.
  PositionCovarianceType position_covariance_type = 5;
}

// A transform between two reference frames in 3D space
message FrameTransform {
  // Timestamp of transform
  google.protobuf.Timestamp timestamp = 1;

  // Name of the parent frame
  string parent_frame_id = 2;

  // Name of the child frame
  string child_frame_id = 3;

  // Translation component of the transform
  foxglove.Vector3 translation = 4;

  // Rotation component of the transform
  foxglove.Quaternion rotation = 5;
}

// An array of FrameTransform messages
message FrameTransforms {
  // Array of transforms
  repeated foxglove.FrameTransform transforms = 1;
}