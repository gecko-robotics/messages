syntax = "proto3";

package kevin;

import "header.proto";

message Image {
  // Timestamp of image
  // google.protobuf.Timestamp timestamp = 1;

  // Frame of reference for the image. The origin of the 
  // frame is the optical center of the camera. +x points 
  // to the right in the image, +y points down, and +z 
  // points into the plane of the image.
  // string frame_id = 7;
  // kevin.Header header = 1;

  // Image width
  fixed32 width = 1;

  // Image height
  fixed32 height = 2;

  // Encoding of the raw image data
  // 
  // Supported values: `8UC1`, `8UC3`, `16UC1` (little 
  // endian), `32FC1` (little endian), `bayer_bggr8`, 
  // `bayer_gbrg8`, `bayer_grbg8`, `bayer_rggb8`, `bgr8`, 
  // `bgra8`, `mono8`, `mono16`, `rgb8`, `rgba8`, `uyvy`
  // or `yuv422`, `yuyv` or `yuv422_yuy2`
  string encoding = 3;

  // Byte length of a single row
  fixed32 step = 4;

  // Raw image data
  bytes data = 5;
}

message DisparityImage {
  // Separate header for compatibility with current TimeSynchronizer.
  // Likely to be removed in a later release, use image.header instead.
  kevin.Header header = 1;

  // Floating point disparity image. The disparities are pre-adjusted for any
  // x-offset between the principal points of the two cameras (in the case
  // that they are verged). That is: d = x_l - x_r - (cx_l - cx_r)
  Image image = 2;

  // Stereo geometry. For disparity d, the depth from the camera is Z = fT/d.
  float f = 3; // Focal length, pixels
  float t = 4; // Baseline, world units

  // Subwindow of (potentially) valid disparity values.
  // sensor_msgs/RegionOfInterest valid_window

  // The range of disparities searched.
  // In the disparity image, any disparity less than min_disparity is invalid.
  // The disparity search range defines the horopter, or 3D volume that the
  // stereo algorithm can "see". Points with Z outside of:
  //     Z_min = fT / max_disparity
  //     Z_max = fT / min_disparity
  // could not be found.
  float min_disparity = 5;
  float max_disparity = 6;

  // Smallest allowed disparity increment. The smallest achievable depth range
  // resolution is delta_Z = (Z^2/fT)*delta_d.
  float delta_d = 7;
}