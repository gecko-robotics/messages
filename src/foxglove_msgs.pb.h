// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: foxglove_msgs.proto
// Protobuf C++ Version: 5.29.3

#ifndef foxglove_5fmsgs_2eproto_2epb_2eh
#define foxglove_5fmsgs_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_foxglove_5fmsgs_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_foxglove_5fmsgs_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_foxglove_5fmsgs_2eproto;
namespace foxglove {
class CameraCalibration;
struct CameraCalibrationDefaultTypeInternal;
extern CameraCalibrationDefaultTypeInternal _CameraCalibration_default_instance_;
class CompressedImage;
struct CompressedImageDefaultTypeInternal;
extern CompressedImageDefaultTypeInternal _CompressedImage_default_instance_;
class LaserScan;
struct LaserScanDefaultTypeInternal;
extern LaserScanDefaultTypeInternal _LaserScan_default_instance_;
class LocationFix;
struct LocationFixDefaultTypeInternal;
extern LocationFixDefaultTypeInternal _LocationFix_default_instance_;
class Pose;
struct PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
class Quaternion;
struct QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class RawImage;
struct RawImageDefaultTypeInternal;
extern RawImageDefaultTypeInternal _RawImage_default_instance_;
class Vector3;
struct Vector3DefaultTypeInternal;
extern Vector3DefaultTypeInternal _Vector3_default_instance_;
}  // namespace foxglove
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace foxglove {
enum LocationFix_PositionCovarianceType : int {
  LocationFix_PositionCovarianceType_UNKNOWN = 0,
  LocationFix_PositionCovarianceType_APPROXIMATED = 1,
  LocationFix_PositionCovarianceType_DIAGONAL_KNOWN = 2,
  LocationFix_PositionCovarianceType_KNOWN = 3,
  LocationFix_PositionCovarianceType_LocationFix_PositionCovarianceType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  LocationFix_PositionCovarianceType_LocationFix_PositionCovarianceType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool LocationFix_PositionCovarianceType_IsValid(int value);
extern const uint32_t LocationFix_PositionCovarianceType_internal_data_[];
constexpr LocationFix_PositionCovarianceType LocationFix_PositionCovarianceType_PositionCovarianceType_MIN = static_cast<LocationFix_PositionCovarianceType>(0);
constexpr LocationFix_PositionCovarianceType LocationFix_PositionCovarianceType_PositionCovarianceType_MAX = static_cast<LocationFix_PositionCovarianceType>(3);
constexpr int LocationFix_PositionCovarianceType_PositionCovarianceType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
LocationFix_PositionCovarianceType_descriptor();
template <typename T>
const std::string& LocationFix_PositionCovarianceType_Name(T value) {
  static_assert(std::is_same<T, LocationFix_PositionCovarianceType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PositionCovarianceType_Name().");
  return LocationFix_PositionCovarianceType_Name(static_cast<LocationFix_PositionCovarianceType>(value));
}
template <>
inline const std::string& LocationFix_PositionCovarianceType_Name(LocationFix_PositionCovarianceType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<LocationFix_PositionCovarianceType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool LocationFix_PositionCovarianceType_Parse(absl::string_view name, LocationFix_PositionCovarianceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LocationFix_PositionCovarianceType>(
      LocationFix_PositionCovarianceType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Vector3 final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:foxglove.Vector3) */ {
 public:
  inline Vector3() : Vector3(nullptr) {}
  ~Vector3() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Vector3* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Vector3));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Vector3(
      ::google::protobuf::internal::ConstantInitialized);

  inline Vector3(const Vector3& from) : Vector3(nullptr, from) {}
  inline Vector3(Vector3&& from) noexcept
      : Vector3(nullptr, std::move(from)) {}
  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3& operator=(Vector3&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector3* internal_default_instance() {
    return reinterpret_cast<const Vector3*>(
        &_Vector3_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Vector3& a, Vector3& b) { a.Swap(&b); }
  inline void Swap(Vector3* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector3* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector3* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Vector3>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vector3& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Vector3& from) { Vector3::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Vector3* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "foxglove.Vector3"; }

 protected:
  explicit Vector3(::google::protobuf::Arena* arena);
  Vector3(::google::protobuf::Arena* arena, const Vector3& from);
  Vector3(::google::protobuf::Arena* arena, Vector3&& from) noexcept
      : Vector3(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // double x = 1;
  void clear_x() ;
  double x() const;
  void set_x(double value);

  private:
  double _internal_x() const;
  void _internal_set_x(double value);

  public:
  // double y = 2;
  void clear_y() ;
  double y() const;
  void set_y(double value);

  private:
  double _internal_y() const;
  void _internal_set_y(double value);

  public:
  // double z = 3;
  void clear_z() ;
  double z() const;
  void set_z(double value);

  private:
  double _internal_z() const;
  void _internal_set_z(double value);

  public:
  // @@protoc_insertion_point(class_scope:foxglove.Vector3)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Vector3& from_msg);
    double x_;
    double y_;
    double z_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_foxglove_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class Quaternion final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:foxglove.Quaternion) */ {
 public:
  inline Quaternion() : Quaternion(nullptr) {}
  ~Quaternion() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Quaternion* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Quaternion));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Quaternion(
      ::google::protobuf::internal::ConstantInitialized);

  inline Quaternion(const Quaternion& from) : Quaternion(nullptr, from) {}
  inline Quaternion(Quaternion&& from) noexcept
      : Quaternion(nullptr, std::move(from)) {}
  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  inline Quaternion& operator=(Quaternion&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Quaternion& default_instance() {
    return *internal_default_instance();
  }
  static inline const Quaternion* internal_default_instance() {
    return reinterpret_cast<const Quaternion*>(
        &_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Quaternion& a, Quaternion& b) { a.Swap(&b); }
  inline void Swap(Quaternion* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Quaternion* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Quaternion* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Quaternion>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Quaternion& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Quaternion& from) { Quaternion::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Quaternion* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "foxglove.Quaternion"; }

 protected:
  explicit Quaternion(::google::protobuf::Arena* arena);
  Quaternion(::google::protobuf::Arena* arena, const Quaternion& from);
  Quaternion(::google::protobuf::Arena* arena, Quaternion&& from) noexcept
      : Quaternion(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kWFieldNumber = 4,
  };
  // double x = 1;
  void clear_x() ;
  double x() const;
  void set_x(double value);

  private:
  double _internal_x() const;
  void _internal_set_x(double value);

  public:
  // double y = 2;
  void clear_y() ;
  double y() const;
  void set_y(double value);

  private:
  double _internal_y() const;
  void _internal_set_y(double value);

  public:
  // double z = 3;
  void clear_z() ;
  double z() const;
  void set_z(double value);

  private:
  double _internal_z() const;
  void _internal_set_z(double value);

  public:
  // double w = 4;
  void clear_w() ;
  double w() const;
  void set_w(double value);

  private:
  double _internal_w() const;
  void _internal_set_w(double value);

  public:
  // @@protoc_insertion_point(class_scope:foxglove.Quaternion)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Quaternion& from_msg);
    double x_;
    double y_;
    double z_;
    double w_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_foxglove_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class RawImage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:foxglove.RawImage) */ {
 public:
  inline RawImage() : RawImage(nullptr) {}
  ~RawImage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RawImage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RawImage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RawImage(
      ::google::protobuf::internal::ConstantInitialized);

  inline RawImage(const RawImage& from) : RawImage(nullptr, from) {}
  inline RawImage(RawImage&& from) noexcept
      : RawImage(nullptr, std::move(from)) {}
  inline RawImage& operator=(const RawImage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RawImage& operator=(RawImage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RawImage& default_instance() {
    return *internal_default_instance();
  }
  static inline const RawImage* internal_default_instance() {
    return reinterpret_cast<const RawImage*>(
        &_RawImage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(RawImage& a, RawImage& b) { a.Swap(&b); }
  inline void Swap(RawImage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RawImage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RawImage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RawImage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RawImage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RawImage& from) { RawImage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RawImage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "foxglove.RawImage"; }

 protected:
  explicit RawImage(::google::protobuf::Arena* arena);
  RawImage(::google::protobuf::Arena* arena, const RawImage& from);
  RawImage(::google::protobuf::Arena* arena, RawImage&& from) noexcept
      : RawImage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEncodingFieldNumber = 4,
    kDataFieldNumber = 6,
    kFrameIdFieldNumber = 7,
    kTimestampFieldNumber = 1,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
    kStepFieldNumber = 5,
  };
  // string encoding = 4;
  void clear_encoding() ;
  const std::string& encoding() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_encoding(Arg_&& arg, Args_... args);
  std::string* mutable_encoding();
  PROTOBUF_NODISCARD std::string* release_encoding();
  void set_allocated_encoding(std::string* value);

  private:
  const std::string& _internal_encoding() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encoding(
      const std::string& value);
  std::string* _internal_mutable_encoding();

  public:
  // bytes data = 6;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // string frame_id = 7;
  void clear_frame_id() ;
  const std::string& frame_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_frame_id(Arg_&& arg, Args_... args);
  std::string* mutable_frame_id();
  PROTOBUF_NODISCARD std::string* release_frame_id();
  void set_allocated_frame_id(std::string* value);

  private:
  const std::string& _internal_frame_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_id(
      const std::string& value);
  std::string* _internal_mutable_frame_id();

  public:
  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::google::protobuf::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_timestamp();
  ::google::protobuf::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_timestamp();

  private:
  const ::google::protobuf::Timestamp& _internal_timestamp() const;
  ::google::protobuf::Timestamp* _internal_mutable_timestamp();

  public:
  // fixed32 width = 2;
  void clear_width() ;
  ::uint32_t width() const;
  void set_width(::uint32_t value);

  private:
  ::uint32_t _internal_width() const;
  void _internal_set_width(::uint32_t value);

  public:
  // fixed32 height = 3;
  void clear_height() ;
  ::uint32_t height() const;
  void set_height(::uint32_t value);

  private:
  ::uint32_t _internal_height() const;
  void _internal_set_height(::uint32_t value);

  public:
  // fixed32 step = 5;
  void clear_step() ;
  ::uint32_t step() const;
  void set_step(::uint32_t value);

  private:
  ::uint32_t _internal_step() const;
  void _internal_set_step(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:foxglove.RawImage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      42, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RawImage& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr encoding_;
    ::google::protobuf::internal::ArenaStringPtr data_;
    ::google::protobuf::internal::ArenaStringPtr frame_id_;
    ::google::protobuf::Timestamp* timestamp_;
    ::uint32_t width_;
    ::uint32_t height_;
    ::uint32_t step_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_foxglove_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class Pose final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:foxglove.Pose) */ {
 public:
  inline Pose() : Pose(nullptr) {}
  ~Pose() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Pose* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Pose));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Pose(
      ::google::protobuf::internal::ConstantInitialized);

  inline Pose(const Pose& from) : Pose(nullptr, from) {}
  inline Pose(Pose&& from) noexcept
      : Pose(nullptr, std::move(from)) {}
  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pose& operator=(Pose&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pose& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pose* internal_default_instance() {
    return reinterpret_cast<const Pose*>(
        &_Pose_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Pose& a, Pose& b) { a.Swap(&b); }
  inline void Swap(Pose* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pose* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pose* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Pose>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Pose& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Pose& from) { Pose::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Pose* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "foxglove.Pose"; }

 protected:
  explicit Pose(::google::protobuf::Arena* arena);
  Pose(::google::protobuf::Arena* arena, const Pose& from);
  Pose(::google::protobuf::Arena* arena, Pose&& from) noexcept
      : Pose(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionFieldNumber = 1,
    kOrientationFieldNumber = 2,
  };
  // .foxglove.Vector3 position = 1;
  bool has_position() const;
  void clear_position() ;
  const ::foxglove::Vector3& position() const;
  PROTOBUF_NODISCARD ::foxglove::Vector3* release_position();
  ::foxglove::Vector3* mutable_position();
  void set_allocated_position(::foxglove::Vector3* value);
  void unsafe_arena_set_allocated_position(::foxglove::Vector3* value);
  ::foxglove::Vector3* unsafe_arena_release_position();

  private:
  const ::foxglove::Vector3& _internal_position() const;
  ::foxglove::Vector3* _internal_mutable_position();

  public:
  // .foxglove.Quaternion orientation = 2;
  bool has_orientation() const;
  void clear_orientation() ;
  const ::foxglove::Quaternion& orientation() const;
  PROTOBUF_NODISCARD ::foxglove::Quaternion* release_orientation();
  ::foxglove::Quaternion* mutable_orientation();
  void set_allocated_orientation(::foxglove::Quaternion* value);
  void unsafe_arena_set_allocated_orientation(::foxglove::Quaternion* value);
  ::foxglove::Quaternion* unsafe_arena_release_orientation();

  private:
  const ::foxglove::Quaternion& _internal_orientation() const;
  ::foxglove::Quaternion* _internal_mutable_orientation();

  public:
  // @@protoc_insertion_point(class_scope:foxglove.Pose)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Pose& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::foxglove::Vector3* position_;
    ::foxglove::Quaternion* orientation_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_foxglove_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class LocationFix final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:foxglove.LocationFix) */ {
 public:
  inline LocationFix() : LocationFix(nullptr) {}
  ~LocationFix() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LocationFix* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LocationFix));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LocationFix(
      ::google::protobuf::internal::ConstantInitialized);

  inline LocationFix(const LocationFix& from) : LocationFix(nullptr, from) {}
  inline LocationFix(LocationFix&& from) noexcept
      : LocationFix(nullptr, std::move(from)) {}
  inline LocationFix& operator=(const LocationFix& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocationFix& operator=(LocationFix&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocationFix& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocationFix* internal_default_instance() {
    return reinterpret_cast<const LocationFix*>(
        &_LocationFix_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(LocationFix& a, LocationFix& b) { a.Swap(&b); }
  inline void Swap(LocationFix* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocationFix* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocationFix* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LocationFix>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LocationFix& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LocationFix& from) { LocationFix::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LocationFix* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "foxglove.LocationFix"; }

 protected:
  explicit LocationFix(::google::protobuf::Arena* arena);
  LocationFix(::google::protobuf::Arena* arena, const LocationFix& from);
  LocationFix(::google::protobuf::Arena* arena, LocationFix&& from) noexcept
      : LocationFix(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using PositionCovarianceType = LocationFix_PositionCovarianceType;
  static constexpr PositionCovarianceType UNKNOWN = LocationFix_PositionCovarianceType_UNKNOWN;
  static constexpr PositionCovarianceType APPROXIMATED = LocationFix_PositionCovarianceType_APPROXIMATED;
  static constexpr PositionCovarianceType DIAGONAL_KNOWN = LocationFix_PositionCovarianceType_DIAGONAL_KNOWN;
  static constexpr PositionCovarianceType KNOWN = LocationFix_PositionCovarianceType_KNOWN;
  static inline bool PositionCovarianceType_IsValid(int value) {
    return LocationFix_PositionCovarianceType_IsValid(value);
  }
  static constexpr PositionCovarianceType PositionCovarianceType_MIN = LocationFix_PositionCovarianceType_PositionCovarianceType_MIN;
  static constexpr PositionCovarianceType PositionCovarianceType_MAX = LocationFix_PositionCovarianceType_PositionCovarianceType_MAX;
  static constexpr int PositionCovarianceType_ARRAYSIZE = LocationFix_PositionCovarianceType_PositionCovarianceType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PositionCovarianceType_descriptor() {
    return LocationFix_PositionCovarianceType_descriptor();
  }
  template <typename T>
  static inline const std::string& PositionCovarianceType_Name(T value) {
    return LocationFix_PositionCovarianceType_Name(value);
  }
  static inline bool PositionCovarianceType_Parse(absl::string_view name, PositionCovarianceType* value) {
    return LocationFix_PositionCovarianceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kPositionCovarianceFieldNumber = 4,
    kFrameIdFieldNumber = 7,
    kTimestampFieldNumber = 6,
    kLatitudeFieldNumber = 1,
    kLongitudeFieldNumber = 2,
    kAltitudeFieldNumber = 3,
    kPositionCovarianceTypeFieldNumber = 5,
  };
  // repeated double position_covariance = 4;
  int position_covariance_size() const;
  private:
  int _internal_position_covariance_size() const;

  public:
  void clear_position_covariance() ;
  double position_covariance(int index) const;
  void set_position_covariance(int index, double value);
  void add_position_covariance(double value);
  const ::google::protobuf::RepeatedField<double>& position_covariance() const;
  ::google::protobuf::RepeatedField<double>* mutable_position_covariance();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_position_covariance() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_position_covariance();

  public:
  // string frame_id = 7;
  void clear_frame_id() ;
  const std::string& frame_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_frame_id(Arg_&& arg, Args_... args);
  std::string* mutable_frame_id();
  PROTOBUF_NODISCARD std::string* release_frame_id();
  void set_allocated_frame_id(std::string* value);

  private:
  const std::string& _internal_frame_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_id(
      const std::string& value);
  std::string* _internal_mutable_frame_id();

  public:
  // .google.protobuf.Timestamp timestamp = 6;
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::google::protobuf::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_timestamp();
  ::google::protobuf::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_timestamp();

  private:
  const ::google::protobuf::Timestamp& _internal_timestamp() const;
  ::google::protobuf::Timestamp* _internal_mutable_timestamp();

  public:
  // double latitude = 1;
  void clear_latitude() ;
  double latitude() const;
  void set_latitude(double value);

  private:
  double _internal_latitude() const;
  void _internal_set_latitude(double value);

  public:
  // double longitude = 2;
  void clear_longitude() ;
  double longitude() const;
  void set_longitude(double value);

  private:
  double _internal_longitude() const;
  void _internal_set_longitude(double value);

  public:
  // double altitude = 3;
  void clear_altitude() ;
  double altitude() const;
  void set_altitude(double value);

  private:
  double _internal_altitude() const;
  void _internal_set_altitude(double value);

  public:
  // .foxglove.LocationFix.PositionCovarianceType position_covariance_type = 5;
  void clear_position_covariance_type() ;
  ::foxglove::LocationFix_PositionCovarianceType position_covariance_type() const;
  void set_position_covariance_type(::foxglove::LocationFix_PositionCovarianceType value);

  private:
  ::foxglove::LocationFix_PositionCovarianceType _internal_position_covariance_type() const;
  void _internal_set_position_covariance_type(::foxglove::LocationFix_PositionCovarianceType value);

  public:
  // @@protoc_insertion_point(class_scope:foxglove.LocationFix)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      37, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LocationFix& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<double> position_covariance_;
    ::google::protobuf::internal::ArenaStringPtr frame_id_;
    ::google::protobuf::Timestamp* timestamp_;
    double latitude_;
    double longitude_;
    double altitude_;
    int position_covariance_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_foxglove_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class CompressedImage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:foxglove.CompressedImage) */ {
 public:
  inline CompressedImage() : CompressedImage(nullptr) {}
  ~CompressedImage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CompressedImage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CompressedImage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CompressedImage(
      ::google::protobuf::internal::ConstantInitialized);

  inline CompressedImage(const CompressedImage& from) : CompressedImage(nullptr, from) {}
  inline CompressedImage(CompressedImage&& from) noexcept
      : CompressedImage(nullptr, std::move(from)) {}
  inline CompressedImage& operator=(const CompressedImage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompressedImage& operator=(CompressedImage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompressedImage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompressedImage* internal_default_instance() {
    return reinterpret_cast<const CompressedImage*>(
        &_CompressedImage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(CompressedImage& a, CompressedImage& b) { a.Swap(&b); }
  inline void Swap(CompressedImage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompressedImage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompressedImage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CompressedImage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CompressedImage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CompressedImage& from) { CompressedImage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CompressedImage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "foxglove.CompressedImage"; }

 protected:
  explicit CompressedImage(::google::protobuf::Arena* arena);
  CompressedImage(::google::protobuf::Arena* arena, const CompressedImage& from);
  CompressedImage(::google::protobuf::Arena* arena, CompressedImage&& from) noexcept
      : CompressedImage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 2,
    kFormatFieldNumber = 3,
    kFrameIdFieldNumber = 4,
    kTimestampFieldNumber = 1,
  };
  // bytes data = 2;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // string format = 3;
  void clear_format() ;
  const std::string& format() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_format(Arg_&& arg, Args_... args);
  std::string* mutable_format();
  PROTOBUF_NODISCARD std::string* release_format();
  void set_allocated_format(std::string* value);

  private:
  const std::string& _internal_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_format(
      const std::string& value);
  std::string* _internal_mutable_format();

  public:
  // string frame_id = 4;
  void clear_frame_id() ;
  const std::string& frame_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_frame_id(Arg_&& arg, Args_... args);
  std::string* mutable_frame_id();
  PROTOBUF_NODISCARD std::string* release_frame_id();
  void set_allocated_frame_id(std::string* value);

  private:
  const std::string& _internal_frame_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_id(
      const std::string& value);
  std::string* _internal_mutable_frame_id();

  public:
  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::google::protobuf::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_timestamp();
  ::google::protobuf::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_timestamp();

  private:
  const ::google::protobuf::Timestamp& _internal_timestamp() const;
  ::google::protobuf::Timestamp* _internal_mutable_timestamp();

  public:
  // @@protoc_insertion_point(class_scope:foxglove.CompressedImage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      47, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CompressedImage& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr data_;
    ::google::protobuf::internal::ArenaStringPtr format_;
    ::google::protobuf::internal::ArenaStringPtr frame_id_;
    ::google::protobuf::Timestamp* timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_foxglove_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class CameraCalibration final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:foxglove.CameraCalibration) */ {
 public:
  inline CameraCalibration() : CameraCalibration(nullptr) {}
  ~CameraCalibration() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CameraCalibration* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CameraCalibration));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CameraCalibration(
      ::google::protobuf::internal::ConstantInitialized);

  inline CameraCalibration(const CameraCalibration& from) : CameraCalibration(nullptr, from) {}
  inline CameraCalibration(CameraCalibration&& from) noexcept
      : CameraCalibration(nullptr, std::move(from)) {}
  inline CameraCalibration& operator=(const CameraCalibration& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraCalibration& operator=(CameraCalibration&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CameraCalibration& default_instance() {
    return *internal_default_instance();
  }
  static inline const CameraCalibration* internal_default_instance() {
    return reinterpret_cast<const CameraCalibration*>(
        &_CameraCalibration_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(CameraCalibration& a, CameraCalibration& b) { a.Swap(&b); }
  inline void Swap(CameraCalibration* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CameraCalibration* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CameraCalibration* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CameraCalibration>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CameraCalibration& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CameraCalibration& from) { CameraCalibration::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CameraCalibration* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "foxglove.CameraCalibration"; }

 protected:
  explicit CameraCalibration(::google::protobuf::Arena* arena);
  CameraCalibration(::google::protobuf::Arena* arena, const CameraCalibration& from);
  CameraCalibration(::google::protobuf::Arena* arena, CameraCalibration&& from) noexcept
      : CameraCalibration(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDFieldNumber = 5,
    kKFieldNumber = 6,
    kRFieldNumber = 7,
    kPFieldNumber = 8,
    kDistortionModelFieldNumber = 4,
    kFrameIdFieldNumber = 9,
    kTimestampFieldNumber = 1,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
  };
  // repeated double D = 5;
  int d_size() const;
  private:
  int _internal_d_size() const;

  public:
  void clear_d() ;
  double d(int index) const;
  void set_d(int index, double value);
  void add_d(double value);
  const ::google::protobuf::RepeatedField<double>& d() const;
  ::google::protobuf::RepeatedField<double>* mutable_d();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_d() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_d();

  public:
  // repeated double K = 6;
  int k_size() const;
  private:
  int _internal_k_size() const;

  public:
  void clear_k() ;
  double k(int index) const;
  void set_k(int index, double value);
  void add_k(double value);
  const ::google::protobuf::RepeatedField<double>& k() const;
  ::google::protobuf::RepeatedField<double>* mutable_k();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_k() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_k();

  public:
  // repeated double R = 7;
  int r_size() const;
  private:
  int _internal_r_size() const;

  public:
  void clear_r() ;
  double r(int index) const;
  void set_r(int index, double value);
  void add_r(double value);
  const ::google::protobuf::RepeatedField<double>& r() const;
  ::google::protobuf::RepeatedField<double>* mutable_r();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_r() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_r();

  public:
  // repeated double P = 8;
  int p_size() const;
  private:
  int _internal_p_size() const;

  public:
  void clear_p() ;
  double p(int index) const;
  void set_p(int index, double value);
  void add_p(double value);
  const ::google::protobuf::RepeatedField<double>& p() const;
  ::google::protobuf::RepeatedField<double>* mutable_p();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_p() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_p();

  public:
  // string distortion_model = 4;
  void clear_distortion_model() ;
  const std::string& distortion_model() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_distortion_model(Arg_&& arg, Args_... args);
  std::string* mutable_distortion_model();
  PROTOBUF_NODISCARD std::string* release_distortion_model();
  void set_allocated_distortion_model(std::string* value);

  private:
  const std::string& _internal_distortion_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_distortion_model(
      const std::string& value);
  std::string* _internal_mutable_distortion_model();

  public:
  // string frame_id = 9;
  void clear_frame_id() ;
  const std::string& frame_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_frame_id(Arg_&& arg, Args_... args);
  std::string* mutable_frame_id();
  PROTOBUF_NODISCARD std::string* release_frame_id();
  void set_allocated_frame_id(std::string* value);

  private:
  const std::string& _internal_frame_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_id(
      const std::string& value);
  std::string* _internal_mutable_frame_id();

  public:
  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::google::protobuf::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_timestamp();
  ::google::protobuf::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_timestamp();

  private:
  const ::google::protobuf::Timestamp& _internal_timestamp() const;
  ::google::protobuf::Timestamp* _internal_mutable_timestamp();

  public:
  // fixed32 width = 2;
  void clear_width() ;
  ::uint32_t width() const;
  void set_width(::uint32_t value);

  private:
  ::uint32_t _internal_width() const;
  void _internal_set_width(::uint32_t value);

  public:
  // fixed32 height = 3;
  void clear_height() ;
  ::uint32_t height() const;
  void set_height(::uint32_t value);

  private:
  ::uint32_t _internal_height() const;
  void _internal_set_height(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:foxglove.CameraCalibration)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 1,
      67, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CameraCalibration& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<double> d_;
    ::google::protobuf::RepeatedField<double> k_;
    ::google::protobuf::RepeatedField<double> r_;
    ::google::protobuf::RepeatedField<double> p_;
    ::google::protobuf::internal::ArenaStringPtr distortion_model_;
    ::google::protobuf::internal::ArenaStringPtr frame_id_;
    ::google::protobuf::Timestamp* timestamp_;
    ::uint32_t width_;
    ::uint32_t height_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_foxglove_5fmsgs_2eproto;
};
// -------------------------------------------------------------------

class LaserScan final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:foxglove.LaserScan) */ {
 public:
  inline LaserScan() : LaserScan(nullptr) {}
  ~LaserScan() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LaserScan* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LaserScan));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LaserScan(
      ::google::protobuf::internal::ConstantInitialized);

  inline LaserScan(const LaserScan& from) : LaserScan(nullptr, from) {}
  inline LaserScan(LaserScan&& from) noexcept
      : LaserScan(nullptr, std::move(from)) {}
  inline LaserScan& operator=(const LaserScan& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaserScan& operator=(LaserScan&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaserScan& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaserScan* internal_default_instance() {
    return reinterpret_cast<const LaserScan*>(
        &_LaserScan_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(LaserScan& a, LaserScan& b) { a.Swap(&b); }
  inline void Swap(LaserScan* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaserScan* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaserScan* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LaserScan>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LaserScan& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LaserScan& from) { LaserScan::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LaserScan* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "foxglove.LaserScan"; }

 protected:
  explicit LaserScan(::google::protobuf::Arena* arena);
  LaserScan(::google::protobuf::Arena* arena, const LaserScan& from);
  LaserScan(::google::protobuf::Arena* arena, LaserScan&& from) noexcept
      : LaserScan(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRangesFieldNumber = 6,
    kIntensitiesFieldNumber = 7,
    kFrameIdFieldNumber = 2,
    kTimestampFieldNumber = 1,
    kPoseFieldNumber = 3,
    kStartAngleFieldNumber = 4,
    kEndAngleFieldNumber = 5,
  };
  // repeated double ranges = 6;
  int ranges_size() const;
  private:
  int _internal_ranges_size() const;

  public:
  void clear_ranges() ;
  double ranges(int index) const;
  void set_ranges(int index, double value);
  void add_ranges(double value);
  const ::google::protobuf::RepeatedField<double>& ranges() const;
  ::google::protobuf::RepeatedField<double>* mutable_ranges();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_ranges() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_ranges();

  public:
  // repeated double intensities = 7;
  int intensities_size() const;
  private:
  int _internal_intensities_size() const;

  public:
  void clear_intensities() ;
  double intensities(int index) const;
  void set_intensities(int index, double value);
  void add_intensities(double value);
  const ::google::protobuf::RepeatedField<double>& intensities() const;
  ::google::protobuf::RepeatedField<double>* mutable_intensities();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_intensities() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_intensities();

  public:
  // string frame_id = 2;
  void clear_frame_id() ;
  const std::string& frame_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_frame_id(Arg_&& arg, Args_... args);
  std::string* mutable_frame_id();
  PROTOBUF_NODISCARD std::string* release_frame_id();
  void set_allocated_frame_id(std::string* value);

  private:
  const std::string& _internal_frame_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_id(
      const std::string& value);
  std::string* _internal_mutable_frame_id();

  public:
  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::google::protobuf::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_timestamp();
  ::google::protobuf::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_timestamp();

  private:
  const ::google::protobuf::Timestamp& _internal_timestamp() const;
  ::google::protobuf::Timestamp* _internal_mutable_timestamp();

  public:
  // .foxglove.Pose pose = 3;
  bool has_pose() const;
  void clear_pose() ;
  const ::foxglove::Pose& pose() const;
  PROTOBUF_NODISCARD ::foxglove::Pose* release_pose();
  ::foxglove::Pose* mutable_pose();
  void set_allocated_pose(::foxglove::Pose* value);
  void unsafe_arena_set_allocated_pose(::foxglove::Pose* value);
  ::foxglove::Pose* unsafe_arena_release_pose();

  private:
  const ::foxglove::Pose& _internal_pose() const;
  ::foxglove::Pose* _internal_mutable_pose();

  public:
  // double start_angle = 4;
  void clear_start_angle() ;
  double start_angle() const;
  void set_start_angle(double value);

  private:
  double _internal_start_angle() const;
  void _internal_set_start_angle(double value);

  public:
  // double end_angle = 5;
  void clear_end_angle() ;
  double end_angle() const;
  void set_end_angle(double value);

  private:
  double _internal_end_angle() const;
  void _internal_set_end_angle(double value);

  public:
  // @@protoc_insertion_point(class_scope:foxglove.LaserScan)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 2,
      35, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LaserScan& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<double> ranges_;
    ::google::protobuf::RepeatedField<double> intensities_;
    ::google::protobuf::internal::ArenaStringPtr frame_id_;
    ::google::protobuf::Timestamp* timestamp_;
    ::foxglove::Pose* pose_;
    double start_angle_;
    double end_angle_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_foxglove_5fmsgs_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Quaternion

// double x = 1;
inline void Quaternion::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline double Quaternion::x() const {
  // @@protoc_insertion_point(field_get:foxglove.Quaternion.x)
  return _internal_x();
}
inline void Quaternion::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:foxglove.Quaternion.x)
}
inline double Quaternion::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void Quaternion::_internal_set_x(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// double y = 2;
inline void Quaternion::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
}
inline double Quaternion::y() const {
  // @@protoc_insertion_point(field_get:foxglove.Quaternion.y)
  return _internal_y();
}
inline void Quaternion::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:foxglove.Quaternion.y)
}
inline double Quaternion::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void Quaternion::_internal_set_y(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// double z = 3;
inline void Quaternion::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = 0;
}
inline double Quaternion::z() const {
  // @@protoc_insertion_point(field_get:foxglove.Quaternion.z)
  return _internal_z();
}
inline void Quaternion::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:foxglove.Quaternion.z)
}
inline double Quaternion::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.z_;
}
inline void Quaternion::_internal_set_z(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = value;
}

// double w = 4;
inline void Quaternion::clear_w() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.w_ = 0;
}
inline double Quaternion::w() const {
  // @@protoc_insertion_point(field_get:foxglove.Quaternion.w)
  return _internal_w();
}
inline void Quaternion::set_w(double value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:foxglove.Quaternion.w)
}
inline double Quaternion::_internal_w() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.w_;
}
inline void Quaternion::_internal_set_w(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.w_ = value;
}

// -------------------------------------------------------------------

// Vector3

// double x = 1;
inline void Vector3::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline double Vector3::x() const {
  // @@protoc_insertion_point(field_get:foxglove.Vector3.x)
  return _internal_x();
}
inline void Vector3::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:foxglove.Vector3.x)
}
inline double Vector3::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void Vector3::_internal_set_x(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// double y = 2;
inline void Vector3::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
}
inline double Vector3::y() const {
  // @@protoc_insertion_point(field_get:foxglove.Vector3.y)
  return _internal_y();
}
inline void Vector3::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:foxglove.Vector3.y)
}
inline double Vector3::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void Vector3::_internal_set_y(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// double z = 3;
inline void Vector3::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = 0;
}
inline double Vector3::z() const {
  // @@protoc_insertion_point(field_get:foxglove.Vector3.z)
  return _internal_z();
}
inline void Vector3::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:foxglove.Vector3.z)
}
inline double Vector3::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.z_;
}
inline void Vector3::_internal_set_z(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Pose

// .foxglove.Vector3 position = 1;
inline bool Pose::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void Pose::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::foxglove::Vector3& Pose::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::foxglove::Vector3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::foxglove::Vector3&>(::foxglove::_Vector3_default_instance_);
}
inline const ::foxglove::Vector3& Pose::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:foxglove.Pose.position)
  return _internal_position();
}
inline void Pose::unsafe_arena_set_allocated_position(::foxglove::Vector3* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::foxglove::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:foxglove.Pose.position)
}
inline ::foxglove::Vector3* Pose::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::foxglove::Vector3* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::foxglove::Vector3* Pose::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:foxglove.Pose.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::foxglove::Vector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::foxglove::Vector3* Pose::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::foxglove::Vector3>(GetArena());
    _impl_.position_ = reinterpret_cast<::foxglove::Vector3*>(p);
  }
  return _impl_.position_;
}
inline ::foxglove::Vector3* Pose::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::foxglove::Vector3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:foxglove.Pose.position)
  return _msg;
}
inline void Pose::set_allocated_position(::foxglove::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::foxglove::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:foxglove.Pose.position)
}

// .foxglove.Quaternion orientation = 2;
inline bool Pose::has_orientation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orientation_ != nullptr);
  return value;
}
inline void Pose::clear_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.orientation_ != nullptr) _impl_.orientation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::foxglove::Quaternion& Pose::_internal_orientation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::foxglove::Quaternion* p = _impl_.orientation_;
  return p != nullptr ? *p : reinterpret_cast<const ::foxglove::Quaternion&>(::foxglove::_Quaternion_default_instance_);
}
inline const ::foxglove::Quaternion& Pose::orientation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:foxglove.Pose.orientation)
  return _internal_orientation();
}
inline void Pose::unsafe_arena_set_allocated_orientation(::foxglove::Quaternion* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.orientation_);
  }
  _impl_.orientation_ = reinterpret_cast<::foxglove::Quaternion*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:foxglove.Pose.orientation)
}
inline ::foxglove::Quaternion* Pose::release_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::foxglove::Quaternion* released = _impl_.orientation_;
  _impl_.orientation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::foxglove::Quaternion* Pose::unsafe_arena_release_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:foxglove.Pose.orientation)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::foxglove::Quaternion* temp = _impl_.orientation_;
  _impl_.orientation_ = nullptr;
  return temp;
}
inline ::foxglove::Quaternion* Pose::_internal_mutable_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.orientation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::foxglove::Quaternion>(GetArena());
    _impl_.orientation_ = reinterpret_cast<::foxglove::Quaternion*>(p);
  }
  return _impl_.orientation_;
}
inline ::foxglove::Quaternion* Pose::mutable_orientation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::foxglove::Quaternion* _msg = _internal_mutable_orientation();
  // @@protoc_insertion_point(field_mutable:foxglove.Pose.orientation)
  return _msg;
}
inline void Pose::set_allocated_orientation(::foxglove::Quaternion* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.orientation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.orientation_ = reinterpret_cast<::foxglove::Quaternion*>(value);
  // @@protoc_insertion_point(field_set_allocated:foxglove.Pose.orientation)
}

// -------------------------------------------------------------------

// LaserScan

// .google.protobuf.Timestamp timestamp = 1;
inline bool LaserScan::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& LaserScan::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& LaserScan::timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:foxglove.LaserScan.timestamp)
  return _internal_timestamp();
}
inline void LaserScan::unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:foxglove.LaserScan.timestamp)
}
inline ::google::protobuf::Timestamp* LaserScan::release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* LaserScan::unsafe_arena_release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:foxglove.LaserScan.timestamp)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* LaserScan::_internal_mutable_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.timestamp_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.timestamp_;
}
inline ::google::protobuf::Timestamp* LaserScan::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:foxglove.LaserScan.timestamp)
  return _msg;
}
inline void LaserScan::set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:foxglove.LaserScan.timestamp)
}

// string frame_id = 2;
inline void LaserScan::clear_frame_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_id_.ClearToEmpty();
}
inline const std::string& LaserScan::frame_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:foxglove.LaserScan.frame_id)
  return _internal_frame_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LaserScan::set_frame_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:foxglove.LaserScan.frame_id)
}
inline std::string* LaserScan::mutable_frame_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_frame_id();
  // @@protoc_insertion_point(field_mutable:foxglove.LaserScan.frame_id)
  return _s;
}
inline const std::string& LaserScan::_internal_frame_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.frame_id_.Get();
}
inline void LaserScan::_internal_set_frame_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_id_.Set(value, GetArena());
}
inline std::string* LaserScan::_internal_mutable_frame_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.frame_id_.Mutable( GetArena());
}
inline std::string* LaserScan::release_frame_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:foxglove.LaserScan.frame_id)
  return _impl_.frame_id_.Release();
}
inline void LaserScan::set_allocated_frame_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.frame_id_.IsDefault()) {
    _impl_.frame_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:foxglove.LaserScan.frame_id)
}

// .foxglove.Pose pose = 3;
inline bool LaserScan::has_pose() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pose_ != nullptr);
  return value;
}
inline void LaserScan::clear_pose() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pose_ != nullptr) _impl_.pose_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::foxglove::Pose& LaserScan::_internal_pose() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::foxglove::Pose* p = _impl_.pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::foxglove::Pose&>(::foxglove::_Pose_default_instance_);
}
inline const ::foxglove::Pose& LaserScan::pose() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:foxglove.LaserScan.pose)
  return _internal_pose();
}
inline void LaserScan::unsafe_arena_set_allocated_pose(::foxglove::Pose* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pose_);
  }
  _impl_.pose_ = reinterpret_cast<::foxglove::Pose*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:foxglove.LaserScan.pose)
}
inline ::foxglove::Pose* LaserScan::release_pose() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::foxglove::Pose* released = _impl_.pose_;
  _impl_.pose_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::foxglove::Pose* LaserScan::unsafe_arena_release_pose() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:foxglove.LaserScan.pose)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::foxglove::Pose* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
  return temp;
}
inline ::foxglove::Pose* LaserScan::_internal_mutable_pose() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pose_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::foxglove::Pose>(GetArena());
    _impl_.pose_ = reinterpret_cast<::foxglove::Pose*>(p);
  }
  return _impl_.pose_;
}
inline ::foxglove::Pose* LaserScan::mutable_pose() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::foxglove::Pose* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:foxglove.LaserScan.pose)
  return _msg;
}
inline void LaserScan::set_allocated_pose(::foxglove::Pose* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.pose_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.pose_ = reinterpret_cast<::foxglove::Pose*>(value);
  // @@protoc_insertion_point(field_set_allocated:foxglove.LaserScan.pose)
}

// double start_angle = 4;
inline void LaserScan::clear_start_angle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_angle_ = 0;
}
inline double LaserScan::start_angle() const {
  // @@protoc_insertion_point(field_get:foxglove.LaserScan.start_angle)
  return _internal_start_angle();
}
inline void LaserScan::set_start_angle(double value) {
  _internal_set_start_angle(value);
  // @@protoc_insertion_point(field_set:foxglove.LaserScan.start_angle)
}
inline double LaserScan::_internal_start_angle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.start_angle_;
}
inline void LaserScan::_internal_set_start_angle(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_angle_ = value;
}

// double end_angle = 5;
inline void LaserScan::clear_end_angle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.end_angle_ = 0;
}
inline double LaserScan::end_angle() const {
  // @@protoc_insertion_point(field_get:foxglove.LaserScan.end_angle)
  return _internal_end_angle();
}
inline void LaserScan::set_end_angle(double value) {
  _internal_set_end_angle(value);
  // @@protoc_insertion_point(field_set:foxglove.LaserScan.end_angle)
}
inline double LaserScan::_internal_end_angle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.end_angle_;
}
inline void LaserScan::_internal_set_end_angle(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.end_angle_ = value;
}

// repeated double ranges = 6;
inline int LaserScan::_internal_ranges_size() const {
  return _internal_ranges().size();
}
inline int LaserScan::ranges_size() const {
  return _internal_ranges_size();
}
inline void LaserScan::clear_ranges() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ranges_.Clear();
}
inline double LaserScan::ranges(int index) const {
  // @@protoc_insertion_point(field_get:foxglove.LaserScan.ranges)
  return _internal_ranges().Get(index);
}
inline void LaserScan::set_ranges(int index, double value) {
  _internal_mutable_ranges()->Set(index, value);
  // @@protoc_insertion_point(field_set:foxglove.LaserScan.ranges)
}
inline void LaserScan::add_ranges(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_ranges()->Add(value);
  // @@protoc_insertion_point(field_add:foxglove.LaserScan.ranges)
}
inline const ::google::protobuf::RepeatedField<double>& LaserScan::ranges() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:foxglove.LaserScan.ranges)
  return _internal_ranges();
}
inline ::google::protobuf::RepeatedField<double>* LaserScan::mutable_ranges()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:foxglove.LaserScan.ranges)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_ranges();
}
inline const ::google::protobuf::RepeatedField<double>&
LaserScan::_internal_ranges() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ranges_;
}
inline ::google::protobuf::RepeatedField<double>* LaserScan::_internal_mutable_ranges() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.ranges_;
}

// repeated double intensities = 7;
inline int LaserScan::_internal_intensities_size() const {
  return _internal_intensities().size();
}
inline int LaserScan::intensities_size() const {
  return _internal_intensities_size();
}
inline void LaserScan::clear_intensities() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.intensities_.Clear();
}
inline double LaserScan::intensities(int index) const {
  // @@protoc_insertion_point(field_get:foxglove.LaserScan.intensities)
  return _internal_intensities().Get(index);
}
inline void LaserScan::set_intensities(int index, double value) {
  _internal_mutable_intensities()->Set(index, value);
  // @@protoc_insertion_point(field_set:foxglove.LaserScan.intensities)
}
inline void LaserScan::add_intensities(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_intensities()->Add(value);
  // @@protoc_insertion_point(field_add:foxglove.LaserScan.intensities)
}
inline const ::google::protobuf::RepeatedField<double>& LaserScan::intensities() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:foxglove.LaserScan.intensities)
  return _internal_intensities();
}
inline ::google::protobuf::RepeatedField<double>* LaserScan::mutable_intensities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:foxglove.LaserScan.intensities)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_intensities();
}
inline const ::google::protobuf::RepeatedField<double>&
LaserScan::_internal_intensities() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.intensities_;
}
inline ::google::protobuf::RepeatedField<double>* LaserScan::_internal_mutable_intensities() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.intensities_;
}

// -------------------------------------------------------------------

// CameraCalibration

// .google.protobuf.Timestamp timestamp = 1;
inline bool CameraCalibration::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& CameraCalibration::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& CameraCalibration::timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:foxglove.CameraCalibration.timestamp)
  return _internal_timestamp();
}
inline void CameraCalibration::unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:foxglove.CameraCalibration.timestamp)
}
inline ::google::protobuf::Timestamp* CameraCalibration::release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* CameraCalibration::unsafe_arena_release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:foxglove.CameraCalibration.timestamp)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* CameraCalibration::_internal_mutable_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.timestamp_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.timestamp_;
}
inline ::google::protobuf::Timestamp* CameraCalibration::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:foxglove.CameraCalibration.timestamp)
  return _msg;
}
inline void CameraCalibration::set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:foxglove.CameraCalibration.timestamp)
}

// string frame_id = 9;
inline void CameraCalibration::clear_frame_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_id_.ClearToEmpty();
}
inline const std::string& CameraCalibration::frame_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:foxglove.CameraCalibration.frame_id)
  return _internal_frame_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CameraCalibration::set_frame_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:foxglove.CameraCalibration.frame_id)
}
inline std::string* CameraCalibration::mutable_frame_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_frame_id();
  // @@protoc_insertion_point(field_mutable:foxglove.CameraCalibration.frame_id)
  return _s;
}
inline const std::string& CameraCalibration::_internal_frame_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.frame_id_.Get();
}
inline void CameraCalibration::_internal_set_frame_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_id_.Set(value, GetArena());
}
inline std::string* CameraCalibration::_internal_mutable_frame_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.frame_id_.Mutable( GetArena());
}
inline std::string* CameraCalibration::release_frame_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:foxglove.CameraCalibration.frame_id)
  return _impl_.frame_id_.Release();
}
inline void CameraCalibration::set_allocated_frame_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.frame_id_.IsDefault()) {
    _impl_.frame_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:foxglove.CameraCalibration.frame_id)
}

// fixed32 width = 2;
inline void CameraCalibration::clear_width() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = 0u;
}
inline ::uint32_t CameraCalibration::width() const {
  // @@protoc_insertion_point(field_get:foxglove.CameraCalibration.width)
  return _internal_width();
}
inline void CameraCalibration::set_width(::uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:foxglove.CameraCalibration.width)
}
inline ::uint32_t CameraCalibration::_internal_width() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.width_;
}
inline void CameraCalibration::_internal_set_width(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = value;
}

// fixed32 height = 3;
inline void CameraCalibration::clear_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = 0u;
}
inline ::uint32_t CameraCalibration::height() const {
  // @@protoc_insertion_point(field_get:foxglove.CameraCalibration.height)
  return _internal_height();
}
inline void CameraCalibration::set_height(::uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:foxglove.CameraCalibration.height)
}
inline ::uint32_t CameraCalibration::_internal_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.height_;
}
inline void CameraCalibration::_internal_set_height(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = value;
}

// string distortion_model = 4;
inline void CameraCalibration::clear_distortion_model() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.distortion_model_.ClearToEmpty();
}
inline const std::string& CameraCalibration::distortion_model() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:foxglove.CameraCalibration.distortion_model)
  return _internal_distortion_model();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CameraCalibration::set_distortion_model(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.distortion_model_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:foxglove.CameraCalibration.distortion_model)
}
inline std::string* CameraCalibration::mutable_distortion_model() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_distortion_model();
  // @@protoc_insertion_point(field_mutable:foxglove.CameraCalibration.distortion_model)
  return _s;
}
inline const std::string& CameraCalibration::_internal_distortion_model() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.distortion_model_.Get();
}
inline void CameraCalibration::_internal_set_distortion_model(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.distortion_model_.Set(value, GetArena());
}
inline std::string* CameraCalibration::_internal_mutable_distortion_model() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.distortion_model_.Mutable( GetArena());
}
inline std::string* CameraCalibration::release_distortion_model() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:foxglove.CameraCalibration.distortion_model)
  return _impl_.distortion_model_.Release();
}
inline void CameraCalibration::set_allocated_distortion_model(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.distortion_model_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.distortion_model_.IsDefault()) {
    _impl_.distortion_model_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:foxglove.CameraCalibration.distortion_model)
}

// repeated double D = 5;
inline int CameraCalibration::_internal_d_size() const {
  return _internal_d().size();
}
inline int CameraCalibration::d_size() const {
  return _internal_d_size();
}
inline void CameraCalibration::clear_d() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.d_.Clear();
}
inline double CameraCalibration::d(int index) const {
  // @@protoc_insertion_point(field_get:foxglove.CameraCalibration.D)
  return _internal_d().Get(index);
}
inline void CameraCalibration::set_d(int index, double value) {
  _internal_mutable_d()->Set(index, value);
  // @@protoc_insertion_point(field_set:foxglove.CameraCalibration.D)
}
inline void CameraCalibration::add_d(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_d()->Add(value);
  // @@protoc_insertion_point(field_add:foxglove.CameraCalibration.D)
}
inline const ::google::protobuf::RepeatedField<double>& CameraCalibration::d() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:foxglove.CameraCalibration.D)
  return _internal_d();
}
inline ::google::protobuf::RepeatedField<double>* CameraCalibration::mutable_d()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:foxglove.CameraCalibration.D)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_d();
}
inline const ::google::protobuf::RepeatedField<double>&
CameraCalibration::_internal_d() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.d_;
}
inline ::google::protobuf::RepeatedField<double>* CameraCalibration::_internal_mutable_d() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.d_;
}

// repeated double K = 6;
inline int CameraCalibration::_internal_k_size() const {
  return _internal_k().size();
}
inline int CameraCalibration::k_size() const {
  return _internal_k_size();
}
inline void CameraCalibration::clear_k() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.k_.Clear();
}
inline double CameraCalibration::k(int index) const {
  // @@protoc_insertion_point(field_get:foxglove.CameraCalibration.K)
  return _internal_k().Get(index);
}
inline void CameraCalibration::set_k(int index, double value) {
  _internal_mutable_k()->Set(index, value);
  // @@protoc_insertion_point(field_set:foxglove.CameraCalibration.K)
}
inline void CameraCalibration::add_k(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_k()->Add(value);
  // @@protoc_insertion_point(field_add:foxglove.CameraCalibration.K)
}
inline const ::google::protobuf::RepeatedField<double>& CameraCalibration::k() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:foxglove.CameraCalibration.K)
  return _internal_k();
}
inline ::google::protobuf::RepeatedField<double>* CameraCalibration::mutable_k()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:foxglove.CameraCalibration.K)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_k();
}
inline const ::google::protobuf::RepeatedField<double>&
CameraCalibration::_internal_k() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.k_;
}
inline ::google::protobuf::RepeatedField<double>* CameraCalibration::_internal_mutable_k() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.k_;
}

// repeated double R = 7;
inline int CameraCalibration::_internal_r_size() const {
  return _internal_r().size();
}
inline int CameraCalibration::r_size() const {
  return _internal_r_size();
}
inline void CameraCalibration::clear_r() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.r_.Clear();
}
inline double CameraCalibration::r(int index) const {
  // @@protoc_insertion_point(field_get:foxglove.CameraCalibration.R)
  return _internal_r().Get(index);
}
inline void CameraCalibration::set_r(int index, double value) {
  _internal_mutable_r()->Set(index, value);
  // @@protoc_insertion_point(field_set:foxglove.CameraCalibration.R)
}
inline void CameraCalibration::add_r(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_r()->Add(value);
  // @@protoc_insertion_point(field_add:foxglove.CameraCalibration.R)
}
inline const ::google::protobuf::RepeatedField<double>& CameraCalibration::r() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:foxglove.CameraCalibration.R)
  return _internal_r();
}
inline ::google::protobuf::RepeatedField<double>* CameraCalibration::mutable_r()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:foxglove.CameraCalibration.R)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_r();
}
inline const ::google::protobuf::RepeatedField<double>&
CameraCalibration::_internal_r() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.r_;
}
inline ::google::protobuf::RepeatedField<double>* CameraCalibration::_internal_mutable_r() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.r_;
}

// repeated double P = 8;
inline int CameraCalibration::_internal_p_size() const {
  return _internal_p().size();
}
inline int CameraCalibration::p_size() const {
  return _internal_p_size();
}
inline void CameraCalibration::clear_p() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.p_.Clear();
}
inline double CameraCalibration::p(int index) const {
  // @@protoc_insertion_point(field_get:foxglove.CameraCalibration.P)
  return _internal_p().Get(index);
}
inline void CameraCalibration::set_p(int index, double value) {
  _internal_mutable_p()->Set(index, value);
  // @@protoc_insertion_point(field_set:foxglove.CameraCalibration.P)
}
inline void CameraCalibration::add_p(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_p()->Add(value);
  // @@protoc_insertion_point(field_add:foxglove.CameraCalibration.P)
}
inline const ::google::protobuf::RepeatedField<double>& CameraCalibration::p() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:foxglove.CameraCalibration.P)
  return _internal_p();
}
inline ::google::protobuf::RepeatedField<double>* CameraCalibration::mutable_p()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:foxglove.CameraCalibration.P)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_p();
}
inline const ::google::protobuf::RepeatedField<double>&
CameraCalibration::_internal_p() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.p_;
}
inline ::google::protobuf::RepeatedField<double>* CameraCalibration::_internal_mutable_p() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.p_;
}

// -------------------------------------------------------------------

// CompressedImage

// .google.protobuf.Timestamp timestamp = 1;
inline bool CompressedImage::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& CompressedImage::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& CompressedImage::timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:foxglove.CompressedImage.timestamp)
  return _internal_timestamp();
}
inline void CompressedImage::unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:foxglove.CompressedImage.timestamp)
}
inline ::google::protobuf::Timestamp* CompressedImage::release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* CompressedImage::unsafe_arena_release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:foxglove.CompressedImage.timestamp)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* CompressedImage::_internal_mutable_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.timestamp_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.timestamp_;
}
inline ::google::protobuf::Timestamp* CompressedImage::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:foxglove.CompressedImage.timestamp)
  return _msg;
}
inline void CompressedImage::set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:foxglove.CompressedImage.timestamp)
}

// string frame_id = 4;
inline void CompressedImage::clear_frame_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_id_.ClearToEmpty();
}
inline const std::string& CompressedImage::frame_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:foxglove.CompressedImage.frame_id)
  return _internal_frame_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CompressedImage::set_frame_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:foxglove.CompressedImage.frame_id)
}
inline std::string* CompressedImage::mutable_frame_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_frame_id();
  // @@protoc_insertion_point(field_mutable:foxglove.CompressedImage.frame_id)
  return _s;
}
inline const std::string& CompressedImage::_internal_frame_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.frame_id_.Get();
}
inline void CompressedImage::_internal_set_frame_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_id_.Set(value, GetArena());
}
inline std::string* CompressedImage::_internal_mutable_frame_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.frame_id_.Mutable( GetArena());
}
inline std::string* CompressedImage::release_frame_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:foxglove.CompressedImage.frame_id)
  return _impl_.frame_id_.Release();
}
inline void CompressedImage::set_allocated_frame_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.frame_id_.IsDefault()) {
    _impl_.frame_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:foxglove.CompressedImage.frame_id)
}

// bytes data = 2;
inline void CompressedImage::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.ClearToEmpty();
}
inline const std::string& CompressedImage::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:foxglove.CompressedImage.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CompressedImage::set_data(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:foxglove.CompressedImage.data)
}
inline std::string* CompressedImage::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:foxglove.CompressedImage.data)
  return _s;
}
inline const std::string& CompressedImage::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_.Get();
}
inline void CompressedImage::_internal_set_data(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.Set(value, GetArena());
}
inline std::string* CompressedImage::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* CompressedImage::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:foxglove.CompressedImage.data)
  return _impl_.data_.Release();
}
inline void CompressedImage::set_allocated_data(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:foxglove.CompressedImage.data)
}

// string format = 3;
inline void CompressedImage::clear_format() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.format_.ClearToEmpty();
}
inline const std::string& CompressedImage::format() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:foxglove.CompressedImage.format)
  return _internal_format();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CompressedImage::set_format(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.format_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:foxglove.CompressedImage.format)
}
inline std::string* CompressedImage::mutable_format() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_format();
  // @@protoc_insertion_point(field_mutable:foxglove.CompressedImage.format)
  return _s;
}
inline const std::string& CompressedImage::_internal_format() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.format_.Get();
}
inline void CompressedImage::_internal_set_format(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.format_.Set(value, GetArena());
}
inline std::string* CompressedImage::_internal_mutable_format() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.format_.Mutable( GetArena());
}
inline std::string* CompressedImage::release_format() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:foxglove.CompressedImage.format)
  return _impl_.format_.Release();
}
inline void CompressedImage::set_allocated_format(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.format_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.format_.IsDefault()) {
    _impl_.format_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:foxglove.CompressedImage.format)
}

// -------------------------------------------------------------------

// RawImage

// .google.protobuf.Timestamp timestamp = 1;
inline bool RawImage::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& RawImage::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& RawImage::timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:foxglove.RawImage.timestamp)
  return _internal_timestamp();
}
inline void RawImage::unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:foxglove.RawImage.timestamp)
}
inline ::google::protobuf::Timestamp* RawImage::release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* RawImage::unsafe_arena_release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:foxglove.RawImage.timestamp)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* RawImage::_internal_mutable_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.timestamp_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.timestamp_;
}
inline ::google::protobuf::Timestamp* RawImage::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:foxglove.RawImage.timestamp)
  return _msg;
}
inline void RawImage::set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:foxglove.RawImage.timestamp)
}

// string frame_id = 7;
inline void RawImage::clear_frame_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_id_.ClearToEmpty();
}
inline const std::string& RawImage::frame_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:foxglove.RawImage.frame_id)
  return _internal_frame_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RawImage::set_frame_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:foxglove.RawImage.frame_id)
}
inline std::string* RawImage::mutable_frame_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_frame_id();
  // @@protoc_insertion_point(field_mutable:foxglove.RawImage.frame_id)
  return _s;
}
inline const std::string& RawImage::_internal_frame_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.frame_id_.Get();
}
inline void RawImage::_internal_set_frame_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_id_.Set(value, GetArena());
}
inline std::string* RawImage::_internal_mutable_frame_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.frame_id_.Mutable( GetArena());
}
inline std::string* RawImage::release_frame_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:foxglove.RawImage.frame_id)
  return _impl_.frame_id_.Release();
}
inline void RawImage::set_allocated_frame_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.frame_id_.IsDefault()) {
    _impl_.frame_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:foxglove.RawImage.frame_id)
}

// fixed32 width = 2;
inline void RawImage::clear_width() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = 0u;
}
inline ::uint32_t RawImage::width() const {
  // @@protoc_insertion_point(field_get:foxglove.RawImage.width)
  return _internal_width();
}
inline void RawImage::set_width(::uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:foxglove.RawImage.width)
}
inline ::uint32_t RawImage::_internal_width() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.width_;
}
inline void RawImage::_internal_set_width(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = value;
}

// fixed32 height = 3;
inline void RawImage::clear_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = 0u;
}
inline ::uint32_t RawImage::height() const {
  // @@protoc_insertion_point(field_get:foxglove.RawImage.height)
  return _internal_height();
}
inline void RawImage::set_height(::uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:foxglove.RawImage.height)
}
inline ::uint32_t RawImage::_internal_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.height_;
}
inline void RawImage::_internal_set_height(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = value;
}

// string encoding = 4;
inline void RawImage::clear_encoding() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encoding_.ClearToEmpty();
}
inline const std::string& RawImage::encoding() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:foxglove.RawImage.encoding)
  return _internal_encoding();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RawImage::set_encoding(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encoding_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:foxglove.RawImage.encoding)
}
inline std::string* RawImage::mutable_encoding() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_encoding();
  // @@protoc_insertion_point(field_mutable:foxglove.RawImage.encoding)
  return _s;
}
inline const std::string& RawImage::_internal_encoding() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encoding_.Get();
}
inline void RawImage::_internal_set_encoding(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encoding_.Set(value, GetArena());
}
inline std::string* RawImage::_internal_mutable_encoding() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.encoding_.Mutable( GetArena());
}
inline std::string* RawImage::release_encoding() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:foxglove.RawImage.encoding)
  return _impl_.encoding_.Release();
}
inline void RawImage::set_allocated_encoding(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encoding_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encoding_.IsDefault()) {
    _impl_.encoding_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:foxglove.RawImage.encoding)
}

// fixed32 step = 5;
inline void RawImage::clear_step() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.step_ = 0u;
}
inline ::uint32_t RawImage::step() const {
  // @@protoc_insertion_point(field_get:foxglove.RawImage.step)
  return _internal_step();
}
inline void RawImage::set_step(::uint32_t value) {
  _internal_set_step(value);
  // @@protoc_insertion_point(field_set:foxglove.RawImage.step)
}
inline ::uint32_t RawImage::_internal_step() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.step_;
}
inline void RawImage::_internal_set_step(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.step_ = value;
}

// bytes data = 6;
inline void RawImage::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.ClearToEmpty();
}
inline const std::string& RawImage::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:foxglove.RawImage.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RawImage::set_data(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:foxglove.RawImage.data)
}
inline std::string* RawImage::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:foxglove.RawImage.data)
  return _s;
}
inline const std::string& RawImage::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_.Get();
}
inline void RawImage::_internal_set_data(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.Set(value, GetArena());
}
inline std::string* RawImage::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* RawImage::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:foxglove.RawImage.data)
  return _impl_.data_.Release();
}
inline void RawImage::set_allocated_data(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:foxglove.RawImage.data)
}

// -------------------------------------------------------------------

// LocationFix

// .google.protobuf.Timestamp timestamp = 6;
inline bool LocationFix::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& LocationFix::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& LocationFix::timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:foxglove.LocationFix.timestamp)
  return _internal_timestamp();
}
inline void LocationFix::unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:foxglove.LocationFix.timestamp)
}
inline ::google::protobuf::Timestamp* LocationFix::release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* LocationFix::unsafe_arena_release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:foxglove.LocationFix.timestamp)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* LocationFix::_internal_mutable_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.timestamp_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.timestamp_;
}
inline ::google::protobuf::Timestamp* LocationFix::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:foxglove.LocationFix.timestamp)
  return _msg;
}
inline void LocationFix::set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:foxglove.LocationFix.timestamp)
}

// string frame_id = 7;
inline void LocationFix::clear_frame_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_id_.ClearToEmpty();
}
inline const std::string& LocationFix::frame_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:foxglove.LocationFix.frame_id)
  return _internal_frame_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LocationFix::set_frame_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:foxglove.LocationFix.frame_id)
}
inline std::string* LocationFix::mutable_frame_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_frame_id();
  // @@protoc_insertion_point(field_mutable:foxglove.LocationFix.frame_id)
  return _s;
}
inline const std::string& LocationFix::_internal_frame_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.frame_id_.Get();
}
inline void LocationFix::_internal_set_frame_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_id_.Set(value, GetArena());
}
inline std::string* LocationFix::_internal_mutable_frame_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.frame_id_.Mutable( GetArena());
}
inline std::string* LocationFix::release_frame_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:foxglove.LocationFix.frame_id)
  return _impl_.frame_id_.Release();
}
inline void LocationFix::set_allocated_frame_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.frame_id_.IsDefault()) {
    _impl_.frame_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:foxglove.LocationFix.frame_id)
}

// double latitude = 1;
inline void LocationFix::clear_latitude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latitude_ = 0;
}
inline double LocationFix::latitude() const {
  // @@protoc_insertion_point(field_get:foxglove.LocationFix.latitude)
  return _internal_latitude();
}
inline void LocationFix::set_latitude(double value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:foxglove.LocationFix.latitude)
}
inline double LocationFix::_internal_latitude() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.latitude_;
}
inline void LocationFix::_internal_set_latitude(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latitude_ = value;
}

// double longitude = 2;
inline void LocationFix::clear_longitude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.longitude_ = 0;
}
inline double LocationFix::longitude() const {
  // @@protoc_insertion_point(field_get:foxglove.LocationFix.longitude)
  return _internal_longitude();
}
inline void LocationFix::set_longitude(double value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:foxglove.LocationFix.longitude)
}
inline double LocationFix::_internal_longitude() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.longitude_;
}
inline void LocationFix::_internal_set_longitude(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.longitude_ = value;
}

// double altitude = 3;
inline void LocationFix::clear_altitude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.altitude_ = 0;
}
inline double LocationFix::altitude() const {
  // @@protoc_insertion_point(field_get:foxglove.LocationFix.altitude)
  return _internal_altitude();
}
inline void LocationFix::set_altitude(double value) {
  _internal_set_altitude(value);
  // @@protoc_insertion_point(field_set:foxglove.LocationFix.altitude)
}
inline double LocationFix::_internal_altitude() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.altitude_;
}
inline void LocationFix::_internal_set_altitude(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.altitude_ = value;
}

// repeated double position_covariance = 4;
inline int LocationFix::_internal_position_covariance_size() const {
  return _internal_position_covariance().size();
}
inline int LocationFix::position_covariance_size() const {
  return _internal_position_covariance_size();
}
inline void LocationFix::clear_position_covariance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.position_covariance_.Clear();
}
inline double LocationFix::position_covariance(int index) const {
  // @@protoc_insertion_point(field_get:foxglove.LocationFix.position_covariance)
  return _internal_position_covariance().Get(index);
}
inline void LocationFix::set_position_covariance(int index, double value) {
  _internal_mutable_position_covariance()->Set(index, value);
  // @@protoc_insertion_point(field_set:foxglove.LocationFix.position_covariance)
}
inline void LocationFix::add_position_covariance(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_position_covariance()->Add(value);
  // @@protoc_insertion_point(field_add:foxglove.LocationFix.position_covariance)
}
inline const ::google::protobuf::RepeatedField<double>& LocationFix::position_covariance() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:foxglove.LocationFix.position_covariance)
  return _internal_position_covariance();
}
inline ::google::protobuf::RepeatedField<double>* LocationFix::mutable_position_covariance()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:foxglove.LocationFix.position_covariance)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_position_covariance();
}
inline const ::google::protobuf::RepeatedField<double>&
LocationFix::_internal_position_covariance() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.position_covariance_;
}
inline ::google::protobuf::RepeatedField<double>* LocationFix::_internal_mutable_position_covariance() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.position_covariance_;
}

// .foxglove.LocationFix.PositionCovarianceType position_covariance_type = 5;
inline void LocationFix::clear_position_covariance_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.position_covariance_type_ = 0;
}
inline ::foxglove::LocationFix_PositionCovarianceType LocationFix::position_covariance_type() const {
  // @@protoc_insertion_point(field_get:foxglove.LocationFix.position_covariance_type)
  return _internal_position_covariance_type();
}
inline void LocationFix::set_position_covariance_type(::foxglove::LocationFix_PositionCovarianceType value) {
  _internal_set_position_covariance_type(value);
  // @@protoc_insertion_point(field_set:foxglove.LocationFix.position_covariance_type)
}
inline ::foxglove::LocationFix_PositionCovarianceType LocationFix::_internal_position_covariance_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::foxglove::LocationFix_PositionCovarianceType>(_impl_.position_covariance_type_);
}
inline void LocationFix::_internal_set_position_covariance_type(::foxglove::LocationFix_PositionCovarianceType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.position_covariance_type_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace foxglove


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::foxglove::LocationFix_PositionCovarianceType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::foxglove::LocationFix_PositionCovarianceType>() {
  return ::foxglove::LocationFix_PositionCovarianceType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // foxglove_5fmsgs_2eproto_2epb_2eh
